// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"


// BEGIN AUTOGENERATED
Gyro* RobotMap::gyro = NULL;
AnalogInput* RobotMap::gyroTemp= NULL;
//AnalogRangeFinder* RobotMap::sonic = NULL;
SpeedController* RobotMap::driveFL = NULL;
SpeedController* RobotMap::driveFR = NULL;
SpeedController* RobotMap::driveBL = NULL;
SpeedController* RobotMap::driveBR = NULL;
RobotDrive* RobotMap::baseDrive = NULL;
SpeedController* RobotMap::lift = NULL;
Encoder* RobotMap::armEnc = NULL;
DigitalInput* RobotMap::toteH_MinDIO = NULL;
DigitalInput* RobotMap::canAnd4ToteH_MaxDIO = NULL;
SpeedController* RobotMap::bite= NULL;
DigitalInput* RobotMap::paradeState= NULL;
DigitalInput* RobotMap::chargeState= NULL;
DigitalInput* RobotMap::nulli=NULL;

    // END AUTOGENERATED

void RobotMap::init() {
	// BEGIN AUTOGENERATED
	LiveWindow* lw = LiveWindow::GetInstance();

	gyro = new Gyro(RobotMap::gyro_Port);
	lw->AddSensor("MecDrive", "gyro", gyro);
	gyro->SetSensitivity(gyroSense);
	//gyro->SetPIDSourceParameter(); //Defaults to Angle
	gyro->InitGyro();

	gyroTemp = new AnalogInput(RobotMap::gyroTemp_Port);
	lw->AddSensor("gyroTemp", RobotMap::gyroTemp_Port, gyroTemp);

	//sonic = new AnalogRangeFinder(RobotMap::sonic_Port);
	//lw->AddSensor("MecDrive", "sonic", sonic);
	
	driveFL = new Talon(RobotMap::driveFL_Port);
	lw->AddActuator("MecDrive", "driveFL", (Talon*) driveFL);
	
	driveFR = new Talon(RobotMap::driveFR_Port);
	lw->AddActuator("MecDrive", "driveFR", (Talon*) driveFR);
	
	driveBL = new Talon(RobotMap::driveBL_Port);
	lw->AddActuator("MecDrive", "driveBL", (Talon*) driveBL);
	
	driveBR = new Talon(RobotMap::driveBR_Port);
	lw->AddActuator("MecDrive", "driveBR", (Talon*) driveBR);
	
	baseDrive = new RobotDrive(driveFL, driveBL,
              driveFR, driveBR);
	
	baseDrive->SetSafetyEnabled(false);
        baseDrive->SetExpiration(0.1);
        baseDrive->SetSensitivity(0.5);
        baseDrive->SetMaxOutput(1.0);

	lift = new Victor(RobotMap::lift_Port);
	lw->AddActuator("Arm", "lift", (Victor*) lift);
	
	armEnc = new Encoder(RobotMap::armEnc_PortA, RobotMap::armEnc_PortB, false, Encoder::k4X);
	lw->AddSensor("Arm", "Enc", armEnc);
	armEnc->SetDistancePerPulse(encDistance);
        armEnc->SetPIDSourceParameter(Encoder::kRate);
        armEnc->SetReverseDirection(false);

	toteH_MinDIO = new DigitalInput(RobotMap::toteH_MinDIO_Port);
	lw->AddSensor("Arm", "toteH_MinDIO", toteH_MinDIO);
	
	canAnd4ToteH_MaxDIO = new DigitalInput(RobotMap::canAnd4ToteH_MaxDIO_Port);
	lw->AddSensor("Arm", "canAnd4ToteH_MaxDIO", canAnd4ToteH_MaxDIO);
	
	bite = new Victor(RobotMap::bite_Port);
	lw->AddActuator("Claw", "bite", (Victor*) bite);
	
	chargeState = new DigitalInput(RobotMap::chargeState_Port);
		lw->AddSensor("Claw", "ChargeState", chargeState);

	paradeState = new DigitalInput(RobotMap::paradeState_Port);
		lw->AddSensor("Claw", "paradeState", paradeState);


	nulli= NULL;

}


    // END AUTOGENERATED
















